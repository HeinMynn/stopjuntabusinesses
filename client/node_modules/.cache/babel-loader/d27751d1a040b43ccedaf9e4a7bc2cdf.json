{"ast":null,"code":"function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n} // Generated with Packemon: https://packemon.dev\n// Platform: browser, Support: stable, Format: esm\n\n\nimport React from 'react';\nimport escapeHtml from 'escape-html';\n\nfunction Element(_ref) {\n  var _ref$attributes = _ref.attributes,\n      attributes = _ref$attributes === void 0 ? {} : _ref$attributes,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? null : _ref$children,\n      _ref$selfClose = _ref.selfClose,\n      selfClose = _ref$selfClose === void 0 ? false : _ref$selfClose,\n      Tag = _ref.tagName; // @ts-expect-error BUG: https://github.com/Microsoft/TypeScript/issues/28806\n\n  return selfClose ? /*#__PURE__*/React.createElement(Tag, attributes) : /*#__PURE__*/React.createElement(Tag, attributes, children);\n}\n\nvar Filter = /*#__PURE__*/function () {\n  function Filter() {}\n\n  var _proto = Filter.prototype;\n  /**\n   * Filter and clean an HTML attribute value.\n   */\n\n  _proto.attribute = function attribute(name, value) {\n    return value;\n  }\n  /**\n   * Filter and clean an HTML node.\n   */\n  ;\n\n  _proto.node = function node(name, _node) {\n    return _node;\n  };\n\n  return Filter;\n}();\n/* eslint-disable no-bitwise, no-magic-numbers, sort-keys */\n// https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories\n\n\nvar TYPE_FLOW = 1;\nvar TYPE_SECTION = 1 << 1;\nvar TYPE_HEADING = 1 << 2;\nvar TYPE_PHRASING = 1 << 3;\nvar TYPE_EMBEDDED = 1 << 4;\nvar TYPE_INTERACTIVE = 1 << 5;\nvar TYPE_PALPABLE = 1 << 6; // https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n\nvar tagConfigs = {\n  a: {\n    content: TYPE_FLOW | TYPE_PHRASING,\n    self: false,\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_INTERACTIVE | TYPE_PALPABLE\n  },\n  address: {\n    invalid: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'address', 'article', 'aside', 'section', 'div', 'header', 'footer'],\n    self: false\n  },\n  audio: {\n    children: ['track', 'source']\n  },\n  br: {\n    type: TYPE_FLOW | TYPE_PHRASING,\n    void: true\n  },\n  body: {\n    content: TYPE_FLOW | TYPE_SECTION | TYPE_HEADING | TYPE_PHRASING | TYPE_EMBEDDED | TYPE_INTERACTIVE | TYPE_PALPABLE\n  },\n  button: {\n    content: TYPE_PHRASING,\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_INTERACTIVE | TYPE_PALPABLE\n  },\n  caption: {\n    content: TYPE_FLOW,\n    parent: ['table']\n  },\n  col: {\n    parent: ['colgroup'],\n    void: true\n  },\n  colgroup: {\n    children: ['col'],\n    parent: ['table']\n  },\n  details: {\n    children: ['summary'],\n    type: TYPE_FLOW | TYPE_INTERACTIVE | TYPE_PALPABLE\n  },\n  dd: {\n    content: TYPE_FLOW,\n    parent: ['dl']\n  },\n  dl: {\n    children: ['dt', 'dd'],\n    type: TYPE_FLOW\n  },\n  dt: {\n    content: TYPE_FLOW,\n    invalid: ['footer', 'header'],\n    parent: ['dl']\n  },\n  figcaption: {\n    content: TYPE_FLOW,\n    parent: ['figure']\n  },\n  footer: {\n    invalid: ['footer', 'header']\n  },\n  header: {\n    invalid: ['footer', 'header']\n  },\n  hr: {\n    type: TYPE_FLOW,\n    void: true\n  },\n  img: {\n    void: true\n  },\n  li: {\n    content: TYPE_FLOW,\n    parent: ['ul', 'ol', 'menu']\n  },\n  main: {\n    self: false\n  },\n  ol: {\n    children: ['li'],\n    type: TYPE_FLOW\n  },\n  picture: {\n    children: ['source', 'img'],\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_EMBEDDED\n  },\n  rb: {\n    parent: ['ruby', 'rtc']\n  },\n  rp: {\n    parent: ['ruby', 'rtc']\n  },\n  rt: {\n    content: TYPE_PHRASING,\n    parent: ['ruby', 'rtc']\n  },\n  rtc: {\n    content: TYPE_PHRASING,\n    parent: ['ruby']\n  },\n  ruby: {\n    children: ['rb', 'rp', 'rt', 'rtc']\n  },\n  source: {\n    parent: ['audio', 'video', 'picture'],\n    void: true\n  },\n  summary: {\n    content: TYPE_PHRASING,\n    parent: ['details']\n  },\n  table: {\n    children: ['caption', 'colgroup', 'thead', 'tbody', 'tfoot', 'tr'],\n    type: TYPE_FLOW\n  },\n  tbody: {\n    parent: ['table'],\n    children: ['tr']\n  },\n  td: {\n    content: TYPE_FLOW,\n    parent: ['tr']\n  },\n  tfoot: {\n    parent: ['table'],\n    children: ['tr']\n  },\n  th: {\n    content: TYPE_FLOW,\n    parent: ['tr']\n  },\n  thead: {\n    parent: ['table'],\n    children: ['tr']\n  },\n  tr: {\n    parent: ['table', 'tbody', 'thead', 'tfoot'],\n    children: ['th', 'td']\n  },\n  track: {\n    parent: ['audio', 'video'],\n    void: true\n  },\n  ul: {\n    children: ['li'],\n    type: TYPE_FLOW\n  },\n  video: {\n    children: ['track', 'source']\n  },\n  wbr: {\n    type: TYPE_FLOW | TYPE_PHRASING,\n    void: true\n  }\n};\n\nfunction createConfigBuilder(config) {\n  return function (tagName) {\n    tagConfigs[tagName] = _extends({}, config, tagConfigs[tagName]);\n  };\n}\n\n['address', 'main', 'div', 'figure', 'p', 'pre'].forEach(createConfigBuilder({\n  content: TYPE_FLOW,\n  type: TYPE_FLOW | TYPE_PALPABLE\n}));\n['abbr', 'b', 'bdi', 'bdo', 'cite', 'code', 'data', 'dfn', 'em', 'i', 'kbd', 'mark', 'q', 'ruby', 'samp', 'strong', 'sub', 'sup', 'time', 'u', 'var'].forEach(createConfigBuilder({\n  content: TYPE_PHRASING,\n  type: TYPE_FLOW | TYPE_PHRASING | TYPE_PALPABLE\n}));\n['p', 'pre'].forEach(createConfigBuilder({\n  content: TYPE_PHRASING,\n  type: TYPE_FLOW | TYPE_PALPABLE\n}));\n['s', 'small', 'span', 'del', 'ins'].forEach(createConfigBuilder({\n  content: TYPE_PHRASING,\n  type: TYPE_FLOW | TYPE_PHRASING\n}));\n['article', 'aside', 'footer', 'header', 'nav', 'section', 'blockquote'].forEach(createConfigBuilder({\n  content: TYPE_FLOW,\n  type: TYPE_FLOW | TYPE_SECTION | TYPE_PALPABLE\n}));\n['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].forEach(createConfigBuilder({\n  content: TYPE_PHRASING,\n  type: TYPE_FLOW | TYPE_HEADING | TYPE_PALPABLE\n}));\n['audio', 'canvas', 'iframe', 'img', 'video'].forEach(createConfigBuilder({\n  type: TYPE_FLOW | TYPE_PHRASING | TYPE_EMBEDDED | TYPE_PALPABLE\n})); // Disable this map from being modified\n\nvar TAGS = Object.freeze(tagConfigs); // Tags that should never be allowed, even if the allow list is disabled\n\nvar BANNED_TAG_LIST = ['applet', 'base', 'body', 'command', 'embed', 'frame', 'frameset', 'head', 'html', 'link', 'meta', 'noscript', 'object', 'script', 'style', 'title'];\nvar ALLOWED_TAG_LIST = Object.keys(TAGS).filter(function (tag) {\n  return tag !== 'canvas' && tag !== 'iframe';\n}); // Filters apply to HTML attributes\n\nvar FILTER_ALLOW = 1;\nvar FILTER_DENY = 2;\nvar FILTER_CAST_NUMBER = 3;\nvar FILTER_CAST_BOOL = 4;\nvar FILTER_NO_CAST = 5; // Attributes not listed here will be denied\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\n\nvar ATTRIBUTES = Object.freeze({\n  alt: FILTER_ALLOW,\n  cite: FILTER_ALLOW,\n  class: FILTER_ALLOW,\n  colspan: FILTER_CAST_NUMBER,\n  controls: FILTER_CAST_BOOL,\n  datetime: FILTER_ALLOW,\n  default: FILTER_CAST_BOOL,\n  disabled: FILTER_CAST_BOOL,\n  dir: FILTER_ALLOW,\n  height: FILTER_ALLOW,\n  href: FILTER_ALLOW,\n  id: FILTER_ALLOW,\n  kind: FILTER_ALLOW,\n  label: FILTER_ALLOW,\n  lang: FILTER_ALLOW,\n  loading: FILTER_ALLOW,\n  loop: FILTER_CAST_BOOL,\n  media: FILTER_ALLOW,\n  muted: FILTER_CAST_BOOL,\n  poster: FILTER_ALLOW,\n  role: FILTER_ALLOW,\n  rowspan: FILTER_CAST_NUMBER,\n  scope: FILTER_ALLOW,\n  sizes: FILTER_ALLOW,\n  span: FILTER_CAST_NUMBER,\n  start: FILTER_CAST_NUMBER,\n  style: FILTER_NO_CAST,\n  src: FILTER_ALLOW,\n  srclang: FILTER_ALLOW,\n  srcset: FILTER_ALLOW,\n  target: FILTER_ALLOW,\n  title: FILTER_ALLOW,\n  type: FILTER_ALLOW,\n  width: FILTER_ALLOW\n}); // Attributes to camel case for React props\n\nvar ATTRIBUTES_TO_PROPS = Object.freeze({\n  class: 'className',\n  colspan: 'colSpan',\n  datetime: 'dateTime',\n  rowspan: 'rowSpan',\n  srclang: 'srcLang',\n  srcset: 'srcSet'\n});\nvar INVALID_STYLES = /(url|image|image-set)\\(/i;\n\nvar StyleFilter = /*#__PURE__*/function (_Filter) {\n  _inheritsLoose(StyleFilter, _Filter);\n\n  function StyleFilter() {\n    return _Filter.apply(this, arguments) || this;\n  }\n\n  var _proto2 = StyleFilter.prototype;\n\n  _proto2.attribute = function attribute(name, value) {\n    if (name === 'style') {\n      Object.keys(value).forEach(function (key) {\n        if (String(value[key]).match(INVALID_STYLES)) {\n          // eslint-disable-next-line no-param-reassign\n          delete value[key];\n        }\n      });\n    }\n\n    return value;\n  };\n\n  return StyleFilter;\n}(Filter);\n/* eslint-disable no-bitwise, no-cond-assign, complexity */\n\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar INVALID_ROOTS = /^<(!doctype|(html|head|body)(\\s|>))/i;\nvar ALLOWED_ATTRS = /^(aria\\x2D|data\\x2D|[0-9A-Z_a-z\\u017F\\u212A]+:)/i;\nvar OPEN_TOKEN = /{{{(\\w+)\\/?}}}/;\n\nfunction createDocument() {\n  // Maybe SSR? Just do nothing instead of crashing!\n  if (typeof window === 'undefined' || typeof document === 'undefined') {\n    return undefined;\n  }\n\n  return document.implementation.createHTMLDocument('Interweave');\n}\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(markup, props, matchers, filters) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (matchers === void 0) {\n      matchers = [];\n    }\n\n    if (filters === void 0) {\n      filters = [];\n    }\n\n    this.allowed = void 0;\n    this.banned = void 0;\n    this.blocked = void 0;\n    this.container = void 0;\n    this.content = [];\n    this.props = void 0;\n    this.matchers = void 0;\n    this.filters = void 0;\n    this.keyIndex = void 0;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (markup && typeof markup !== 'string') {\n        throw new TypeError('Interweave parser requires a valid string.');\n      }\n    }\n\n    this.props = props;\n    this.matchers = matchers;\n    this.filters = [].concat(filters, [new StyleFilter()]);\n    this.keyIndex = -1;\n    this.container = this.createContainer(markup || '');\n    this.allowed = new Set(props.allowList || ALLOWED_TAG_LIST);\n    this.banned = new Set(BANNED_TAG_LIST);\n    this.blocked = new Set(props.blockList);\n  }\n  /**\n   * Loop through and apply all registered attribute filters.\n   */\n\n\n  var _proto3 = Parser.prototype;\n\n  _proto3.applyAttributeFilters = function applyAttributeFilters(name, value) {\n    return this.filters.reduce(function (nextValue, filter) {\n      return nextValue !== null && typeof filter.attribute === 'function' ? filter.attribute(name, nextValue) : nextValue;\n    }, value);\n  }\n  /**\n   * Loop through and apply all registered node filters.\n   */\n  ;\n\n  _proto3.applyNodeFilters = function applyNodeFilters(name, node) {\n    // Allow null to be returned\n    return this.filters.reduce(function (nextNode, filter) {\n      return nextNode !== null && typeof filter.node === 'function' ? filter.node(name, nextNode) : nextNode;\n    }, node);\n  }\n  /**\n   * Loop through and apply all registered matchers to the string.\n   * If a match is found, create a React element, and build a new array.\n   * This array allows React to interpolate and render accordingly.\n   */\n  ;\n\n  _proto3.applyMatchers = function applyMatchers(string, parentConfig) {\n    var _this = this;\n\n    var elements = {};\n    var props = this.props;\n    var matchedString = string;\n    var elementIndex = 0;\n    var parts = null;\n    this.matchers.forEach(function (matcher) {\n      var tagName = matcher.asTag().toLowerCase();\n\n      var config = _this.getTagConfig(tagName); // Skip matchers that have been disabled from props or are not supported\n\n\n      if (props[matcher.inverseName] || !_this.isTagAllowed(tagName)) {\n        return;\n      } // Skip matchers in which the child cannot be rendered\n\n\n      if (!_this.canRenderChild(parentConfig, config)) {\n        return;\n      } // Continuously trigger the matcher until no matches are found\n\n\n      var tokenizedString = '';\n\n      while (matchedString && (parts = matcher.match(matchedString))) {\n        var _parts = parts,\n            index = _parts.index,\n            length = _parts.length,\n            _match = _parts.match,\n            valid = _parts.valid,\n            isVoid = _parts.void,\n            partProps = _objectWithoutPropertiesLoose(_parts, [\"index\", \"length\", \"match\", \"valid\", \"void\"]);\n\n        var tokenName = matcher.propName + elementIndex; // Piece together a new string with interpolated tokens\n\n        if (index > 0) {\n          tokenizedString += matchedString.slice(0, index);\n        }\n\n        if (valid) {\n          tokenizedString += isVoid ? \"{{{\" + tokenName + \"/}}}\" : \"{{{\" + tokenName + \"}}}\" + _match + \"{{{/\" + tokenName + \"}}}\";\n          _this.keyIndex += 1;\n          elementIndex += 1;\n          elements[tokenName] = {\n            children: _match,\n            matcher: matcher,\n            props: _extends({}, props, partProps, {\n              key: _this.keyIndex\n            })\n          };\n        } else {\n          tokenizedString += _match;\n        } // Reduce the string being matched against,\n        // otherwise we end up in an infinite loop!\n\n\n        if (matcher.greedy) {\n          matchedString = tokenizedString + matchedString.slice(index + length);\n          tokenizedString = '';\n        } else {\n          // eslint-disable-next-line unicorn/explicit-length-check\n          matchedString = matchedString.slice(index + (length || _match.length));\n        }\n      } // Update the matched string with the tokenized string,\n      // so that the next matcher can apply to it.\n\n\n      if (!matcher.greedy) {\n        matchedString = tokenizedString + matchedString;\n      }\n    });\n\n    if (elementIndex === 0) {\n      return string;\n    }\n\n    return this.replaceTokens(matchedString, elements);\n  }\n  /**\n   * Determine whether the child can be rendered within the parent.\n   */\n  ;\n\n  _proto3.canRenderChild = function canRenderChild(parentConfig, childConfig) {\n    if (!parentConfig.tagName || !childConfig.tagName) {\n      return false;\n    } // No children\n\n\n    if (parentConfig.void) {\n      return false;\n    } // Valid children\n\n\n    if (parentConfig.children.length > 0) {\n      return parentConfig.children.includes(childConfig.tagName);\n    }\n\n    if (parentConfig.invalid.length > 0 && parentConfig.invalid.includes(childConfig.tagName)) {\n      return false;\n    } // Valid parent\n\n\n    if (childConfig.parent.length > 0) {\n      return childConfig.parent.includes(parentConfig.tagName);\n    } // Self nesting\n\n\n    if (!parentConfig.self && parentConfig.tagName === childConfig.tagName) {\n      return false;\n    } // Content category type\n\n\n    return Boolean(parentConfig && parentConfig.content & childConfig.type);\n  }\n  /**\n   * Convert line breaks in a string to HTML `<br/>` tags.\n   * If the string contains HTML, we should not convert anything,\n   * as line breaks should be handled by `<br/>`s in the markup itself.\n   */\n  ;\n\n  _proto3.convertLineBreaks = function convertLineBreaks(markup) {\n    var _this$props = this.props,\n        noHtml = _this$props.noHtml,\n        disableLineBreaks = _this$props.disableLineBreaks;\n\n    if (noHtml || disableLineBreaks || markup.match(/<((?:\\/[ a-z]+)|(?:[ a-z]+\\/))>/gi)) {\n      return markup;\n    } // Replace carriage returns\n\n\n    var nextMarkup = markup.replace(/\\r\\n/g, '\\n'); // Replace long line feeds\n\n    nextMarkup = nextMarkup.replace(/\\n{3,}/g, '\\n\\n\\n'); // Replace line feeds with `<br/>`s\n\n    nextMarkup = nextMarkup.replace(/\\n/g, '<br/>');\n    return nextMarkup;\n  }\n  /**\n   * Create a detached HTML document that allows for easy HTML\n   * parsing while not triggering scripts or loading external\n   * resources.\n   */\n  ;\n\n  _proto3.createContainer = function createContainer(markup) {\n    var factory = global.INTERWEAVE_SSR_POLYFILL || createDocument;\n    var doc = factory();\n\n    if (!doc) {\n      return undefined;\n    }\n\n    var tag = this.props.containerTagName || 'body';\n    var el = tag === 'body' || tag === 'fragment' ? doc.body : doc.createElement(tag);\n\n    if (markup.match(INVALID_ROOTS)) {\n      if (process.env.NODE_ENV !== \"production\") {\n        throw new Error('HTML documents as Interweave content are not supported.');\n      }\n    } else {\n      el.innerHTML = this.convertLineBreaks(this.props.escapeHtml ? escapeHtml(markup) : markup);\n    }\n\n    return el;\n  }\n  /**\n   * Convert an elements attribute map to an object map.\n   * Returns null if no attributes are defined.\n   */\n  ;\n\n  _proto3.extractAttributes = function extractAttributes(node) {\n    var _this2 = this;\n\n    var allowAttributes = this.props.allowAttributes;\n    var attributes = {};\n    var count = 0;\n\n    if (node.nodeType !== ELEMENT_NODE || !node.attributes) {\n      return null;\n    }\n\n    Array.from(node.attributes).forEach(function (attr) {\n      var name = attr.name,\n          value = attr.value;\n      var newName = name.toLowerCase();\n      var filter = ATTRIBUTES[newName] || ATTRIBUTES[name]; // Verify the node is safe from attacks\n\n      if (!_this2.isSafe(node)) {\n        return;\n      } // Do not allow denied attributes, excluding ARIA attributes\n      // Do not allow events or XSS injections\n\n\n      if (!newName.match(ALLOWED_ATTRS)) {\n        if (!allowAttributes && (!filter || filter === FILTER_DENY) || newName.startsWith('on') || value.replace(/(\\s|\\0|&#x0([9AD]);)/, '').match(/(javascript|vbscript|livescript|xss):/i)) {\n          return;\n        }\n      } // Apply attribute filters\n\n\n      var newValue = newName === 'style' ? _this2.extractStyleAttribute(node) : value; // Cast to boolean\n\n      if (filter === FILTER_CAST_BOOL) {\n        newValue = true; // Cast to number\n      } else if (filter === FILTER_CAST_NUMBER) {\n        newValue = Number.parseFloat(String(newValue)); // Cast to string\n      } else if (filter !== FILTER_NO_CAST) {\n        newValue = String(newValue);\n      }\n\n      attributes[ATTRIBUTES_TO_PROPS[newName] || newName] = _this2.applyAttributeFilters(newName, newValue);\n      count += 1;\n    });\n\n    if (count === 0) {\n      return null;\n    }\n\n    return attributes;\n  }\n  /**\n   * Extract the style attribute as an object and remove values that allow for attack vectors.\n   */\n  ;\n\n  _proto3.extractStyleAttribute = function extractStyleAttribute(node) {\n    var styles = {};\n    Array.from(node.style).forEach(function (key) {\n      var value = node.style[key];\n\n      if (typeof value === 'string' || typeof value === 'number') {\n        styles[key.replace(/-([a-z])/g, function (match, letter) {\n          return letter.toUpperCase();\n        })] = value;\n      }\n    });\n    return styles;\n  }\n  /**\n   * Return configuration for a specific tag.\n   */\n  ;\n\n  _proto3.getTagConfig = function getTagConfig(tagName) {\n    var common = {\n      children: [],\n      content: 0,\n      invalid: [],\n      parent: [],\n      self: true,\n      tagName: '',\n      type: 0,\n      void: false\n    }; // Only spread when a tag config exists,\n    // otherwise we use the empty `tagName`\n    // for parent config inheritance.\n\n    if (TAGS[tagName]) {\n      return _extends({}, common, TAGS[tagName], {\n        tagName: tagName\n      });\n    }\n\n    return common;\n  }\n  /**\n   * Verify that a node is safe from XSS and injection attacks.\n   */\n  ;\n\n  _proto3.isSafe = function isSafe(node) {\n    // URLs should only support HTTP, email and phone numbers\n    if (typeof HTMLAnchorElement !== 'undefined' && node instanceof HTMLAnchorElement) {\n      var href = node.getAttribute('href'); // Fragment protocols start with about:\n      // So let's just allow them\n\n      if (href && href.charAt(0) === '#') {\n        return true;\n      }\n\n      var protocol = node.protocol.toLowerCase();\n      return protocol === ':' || protocol === 'http:' || protocol === 'https:' || protocol === 'mailto:' || protocol === 'tel:';\n    }\n\n    return true;\n  }\n  /**\n   * Verify that an HTML tag is allowed to render.\n   */\n  ;\n\n  _proto3.isTagAllowed = function isTagAllowed(tagName) {\n    if (this.banned.has(tagName) || this.blocked.has(tagName)) {\n      return false;\n    }\n\n    return this.props.allowElements || this.allowed.has(tagName);\n  }\n  /**\n   * Parse the markup by injecting it into a detached document,\n   * while looping over all child nodes and generating an\n   * array to interpolate into JSX.\n   */\n  ;\n\n  _proto3.parse = function parse() {\n    if (!this.container) {\n      return [];\n    }\n\n    return this.parseNode(this.container, this.getTagConfig(this.container.nodeName.toLowerCase()));\n  }\n  /**\n   * Loop over the nodes children and generate a\n   * list of text nodes and React elements.\n   */\n  ;\n\n  _proto3.parseNode = function parseNode(parentNode, parentConfig) {\n    var _this3 = this;\n\n    var _this$props2 = this.props,\n        noHtml = _this$props2.noHtml,\n        noHtmlExceptMatchers = _this$props2.noHtmlExceptMatchers,\n        allowElements = _this$props2.allowElements,\n        transform = _this$props2.transform;\n    var content = [];\n    var mergedText = '';\n    Array.from(parentNode.childNodes).forEach(function (node) {\n      // Create React elements from HTML elements\n      if (node.nodeType === ELEMENT_NODE) {\n        var tagName = node.nodeName.toLowerCase();\n\n        var config = _this3.getTagConfig(tagName); // Persist any previous text\n\n\n        if (mergedText) {\n          content.push(mergedText);\n          mergedText = '';\n        } // Apply node filters first\n\n\n        var nextNode = _this3.applyNodeFilters(tagName, node);\n\n        if (!nextNode) {\n          return;\n        } // Apply transformation second\n\n\n        var children;\n\n        if (transform) {\n          _this3.keyIndex += 1;\n          var key = _this3.keyIndex; // Must occur after key is set\n\n          children = _this3.parseNode(nextNode, config);\n          var transformed = transform(nextNode, children, config);\n\n          if (transformed === null) {\n            return;\n          } else if (typeof transformed !== 'undefined') {\n            content.push( /*#__PURE__*/React.cloneElement(transformed, {\n              key: key\n            }));\n            return;\n          } // Reset as we're not using the transformation\n\n\n          _this3.keyIndex = key - 1;\n        } // Never allow these tags (except via a transformer)\n\n\n        if (_this3.banned.has(tagName)) {\n          return;\n        } // Only render when the following criteria is met:\n        //  - HTML has not been disabled\n        //  - Tag is allowed\n        //  - Child is valid within the parent\n\n\n        if (!(noHtml || noHtmlExceptMatchers && tagName !== 'br') && _this3.isTagAllowed(tagName) && (allowElements || _this3.canRenderChild(parentConfig, config))) {\n          _this3.keyIndex += 1; // Build the props as it makes it easier to test\n\n          var attributes = _this3.extractAttributes(nextNode);\n\n          var elementProps = {\n            tagName: tagName\n          };\n\n          if (attributes) {\n            elementProps.attributes = attributes;\n          }\n\n          if (config.void) {\n            elementProps.selfClose = config.void;\n          }\n\n          content.push( /*#__PURE__*/React.createElement(Element, _extends({}, elementProps, {\n            key: _this3.keyIndex\n          }), children || _this3.parseNode(nextNode, config))); // Render the children of the current element only.\n          // Important: If the current element is not allowed,\n          // use the parent element for the next scope.\n        } else {\n          content = content.concat(_this3.parseNode(nextNode, config.tagName ? config : parentConfig));\n        } // Apply matchers if a text node\n\n      } else if (node.nodeType === TEXT_NODE) {\n        var text = noHtml && !noHtmlExceptMatchers ? node.textContent : _this3.applyMatchers(node.textContent || '', parentConfig);\n\n        if (Array.isArray(text)) {\n          content = content.concat(text);\n        } else {\n          mergedText += text;\n        }\n      }\n    });\n\n    if (mergedText) {\n      content.push(mergedText);\n    }\n\n    return content;\n  }\n  /**\n   * Deconstruct the string into an array, by replacing custom tokens with React elements,\n   * so that React can render it correctly.\n   */\n  ;\n\n  _proto3.replaceTokens = function replaceTokens(tokenizedString, elements) {\n    if (!tokenizedString.includes('{{{')) {\n      return tokenizedString;\n    }\n\n    var nodes = [];\n    var text = tokenizedString;\n    var open = null; // Find an open token tag\n\n    while (open = text.match(OPEN_TOKEN)) {\n      var _open = open,\n          _match2 = _open[0],\n          tokenName = _open[1];\n      var startIndex = open.index;\n\n      var isVoid = _match2.includes('/');\n\n      if (process.env.NODE_ENV !== \"production\") {\n        if (!elements[tokenName]) {\n          throw new Error(\"Token \\\"\" + tokenName + \"\\\" found but no matching element to replace with.\");\n        }\n      } // Extract the previous non-token text\n\n\n      if (startIndex > 0) {\n        nodes.push(text.slice(0, startIndex)); // Reduce text so that the closing tag will be found after the opening\n\n        text = text.slice(startIndex);\n      }\n\n      var _elements$tokenName = elements[tokenName],\n          children = _elements$tokenName.children,\n          matcher = _elements$tokenName.matcher,\n          elementProps = _elements$tokenName.props;\n      var endIndex = void 0; // Use tag as-is if void\n\n      if (isVoid) {\n        endIndex = _match2.length;\n        nodes.push(matcher.createElement(children, elementProps)); // Find the closing tag if not void\n      } else {\n        var close = text.match(new RegExp(\"{{{/\" + tokenName + \"}}}\"));\n\n        if (process.env.NODE_ENV !== \"production\") {\n          if (!close) {\n            throw new Error(\"Closing token missing for interpolated element \\\"\" + tokenName + \"\\\".\");\n          }\n        }\n\n        endIndex = close.index + close[0].length;\n        nodes.push(matcher.createElement(this.replaceTokens(text.slice(_match2.length, close.index), elements), elementProps));\n      } // Reduce text for the next interation\n\n\n      text = text.slice(endIndex);\n    } // Extra the remaining text\n\n\n    if (text.length > 0) {\n      nodes.push(text);\n    } // Reduce to a string if possible\n\n\n    if (nodes.length === 0) {\n      return '';\n    } else if (nodes.length === 1 && typeof nodes[0] === 'string') {\n      return nodes[0];\n    }\n\n    return nodes;\n  };\n\n  return Parser;\n}();\n/* eslint-disable react/jsx-fragments */\n\n\nfunction Markup(props) {\n  var attributes = props.attributes,\n      containerTagName = props.containerTagName,\n      content = props.content,\n      emptyContent = props.emptyContent,\n      parsedContent = props.parsedContent,\n      tagName = props.tagName;\n  var tag = containerTagName || tagName || 'div';\n  var noWrap = tag === 'fragment' ? true : props.noWrap;\n  var mainContent;\n\n  if (parsedContent) {\n    mainContent = parsedContent;\n  } else {\n    var markup = new Parser(content || '', props).parse();\n\n    if (markup.length > 0) {\n      mainContent = markup;\n    }\n  }\n\n  if (!mainContent) {\n    mainContent = emptyContent;\n  }\n\n  if (noWrap) {\n    // eslint-disable-next-line react/jsx-no-useless-fragment\n    return /*#__PURE__*/React.createElement(React.Fragment, null, mainContent);\n  }\n\n  return /*#__PURE__*/React.createElement(Element, {\n    attributes: attributes,\n    tagName: tag\n  }, mainContent);\n}\n\nfunction Interweave(props) {\n  var attributes = props.attributes,\n      _props$content = props.content,\n      content = _props$content === void 0 ? '' : _props$content,\n      _props$disableFilters = props.disableFilters,\n      disableFilters = _props$disableFilters === void 0 ? false : _props$disableFilters,\n      _props$disableMatcher = props.disableMatchers,\n      disableMatchers = _props$disableMatcher === void 0 ? false : _props$disableMatcher,\n      _props$emptyContent = props.emptyContent,\n      emptyContent = _props$emptyContent === void 0 ? null : _props$emptyContent,\n      _props$filters = props.filters,\n      filters = _props$filters === void 0 ? [] : _props$filters,\n      _props$matchers = props.matchers,\n      matchers = _props$matchers === void 0 ? [] : _props$matchers,\n      _props$onAfterParse = props.onAfterParse,\n      onAfterParse = _props$onAfterParse === void 0 ? null : _props$onAfterParse,\n      _props$onBeforeParse = props.onBeforeParse,\n      onBeforeParse = _props$onBeforeParse === void 0 ? null : _props$onBeforeParse,\n      _props$tagName = props.tagName,\n      tagName = _props$tagName === void 0 ? 'span' : _props$tagName,\n      _props$noWrap = props.noWrap,\n      noWrap = _props$noWrap === void 0 ? false : _props$noWrap,\n      parserProps = _objectWithoutPropertiesLoose(props, [\"attributes\", \"content\", \"disableFilters\", \"disableMatchers\", \"emptyContent\", \"filters\", \"matchers\", \"onAfterParse\", \"onBeforeParse\", \"tagName\", \"noWrap\"]);\n\n  var allMatchers = disableMatchers ? [] : matchers;\n  var allFilters = disableFilters ? [] : filters;\n  var beforeCallbacks = onBeforeParse ? [onBeforeParse] : [];\n  var afterCallbacks = onAfterParse ? [onAfterParse] : []; // Inherit callbacks from matchers\n\n  allMatchers.forEach(function (matcher) {\n    if (matcher.onBeforeParse) {\n      beforeCallbacks.push(matcher.onBeforeParse.bind(matcher));\n    }\n\n    if (matcher.onAfterParse) {\n      afterCallbacks.push(matcher.onAfterParse.bind(matcher));\n    }\n  }); // Trigger before callbacks\n\n  var markup = beforeCallbacks.reduce(function (string, callback) {\n    var nextString = callback(string, props);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof nextString !== 'string') {\n        throw new TypeError('Interweave `onBeforeParse` must return a valid HTML string.');\n      }\n    }\n\n    return nextString;\n  }, content || ''); // Parse the markup\n\n  var parser = new Parser(markup, parserProps, allMatchers, allFilters); // Trigger after callbacks\n\n  var nodes = afterCallbacks.reduce(function (parserNodes, callback) {\n    var nextNodes = callback(parserNodes, props);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!Array.isArray(nextNodes)) {\n        throw new TypeError('Interweave `onAfterParse` must return an array of strings and React elements.');\n      }\n    }\n\n    return nextNodes;\n  }, parser.parse());\n  return /*#__PURE__*/React.createElement(Markup, {\n    attributes: attributes,\n    containerTagName: props.containerTagName,\n    emptyContent: emptyContent,\n    tagName: tagName,\n    noWrap: noWrap,\n    parsedContent: nodes.length === 0 ? undefined : nodes\n  });\n}\n/**\n * Trigger the actual pattern match and package the matched\n * response through a callback.\n */\n\n\nfunction match(string, pattern, callback, isVoid) {\n  if (isVoid === void 0) {\n    isVoid = false;\n  }\n\n  var matches = string.match(pattern instanceof RegExp ? pattern : new RegExp(pattern, 'i'));\n\n  if (!matches) {\n    return null;\n  }\n\n  return _extends({\n    match: matches[0],\n    void: isVoid\n  }, callback(matches), {\n    index: matches.index,\n    length: matches[0].length,\n    valid: true\n  });\n}\n\nvar Matcher = /*#__PURE__*/function () {\n  function Matcher(name, options, factory) {\n    this.greedy = false;\n    this.options = void 0;\n    this.propName = void 0;\n    this.inverseName = void 0;\n    this.factory = void 0;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!name || name.toLowerCase() === 'html') {\n        throw new Error(\"The matcher name \\\"\" + name + \"\\\" is not allowed.\");\n      }\n    } // @ts-expect-error\n\n\n    this.options = _extends({}, options);\n    this.propName = name;\n    this.inverseName = \"no\" + (name.charAt(0).toUpperCase() + name.slice(1));\n    this.factory = factory || null;\n  }\n  /**\n   * Attempts to create a React element using a custom user provided factory,\n   * or the default matcher factory.\n   */\n\n\n  var _proto4 = Matcher.prototype;\n\n  _proto4.createElement = function createElement(children, props) {\n    var element = this.factory ? /*#__PURE__*/React.createElement(this.factory, props, children) : this.replaceWith(children, props);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof element !== 'string' && ! /*#__PURE__*/React.isValidElement(element)) {\n        throw new Error(\"Invalid React element created from \" + this.constructor.name + \".\");\n      }\n    }\n\n    return element;\n  }\n  /**\n   * Trigger the actual pattern match and package the matched\n   * response through a callback.\n   */\n  ;\n\n  _proto4.doMatch = function doMatch(string, pattern, callback, isVoid) {\n    if (isVoid === void 0) {\n      isVoid = false;\n    }\n\n    return match(string, pattern, callback, isVoid);\n  }\n  /**\n   * Callback triggered before parsing.\n   */\n  ;\n\n  _proto4.onBeforeParse = function onBeforeParse(content, props) {\n    return content;\n  }\n  /**\n   * Callback triggered after parsing.\n   */\n  ;\n\n  _proto4.onAfterParse = function onAfterParse(content, props) {\n    return content;\n  }\n  /**\n   * Replace the match with a React element based on the matched token and optional props.\n   */\n  ;\n\n  return Matcher;\n}();\n/**\n * @copyright   2016-2019, Miles Johnson\n * @license     https://opensource.org/licenses/MIT\n */\n\n\nexport default Interweave;\nexport { ALLOWED_TAG_LIST, ATTRIBUTES, ATTRIBUTES_TO_PROPS, BANNED_TAG_LIST, Element, FILTER_ALLOW, FILTER_CAST_BOOL, FILTER_CAST_NUMBER, FILTER_DENY, FILTER_NO_CAST, Filter, Markup, Matcher, Parser, TAGS, TYPE_EMBEDDED, TYPE_FLOW, TYPE_HEADING, TYPE_INTERACTIVE, TYPE_PALPABLE, TYPE_PHRASING, TYPE_SECTION, match };","map":{"version":3,"sources":["../src/Element.tsx","../src/Filter.ts","../src/constants.ts","../src/StyleFilter.ts","../src/Parser.ts","../src/Markup.tsx","../src/Interweave.tsx","../src/match.ts","../src/Matcher.ts","../src/index.ts"],"names":["attributes","children","tagName","Tag","attribute","node","TYPE_HEADING","TYPE_PHRASING","TYPE_EMBEDDED","TYPE_PALPABLE","a","type","TYPE_FLOW","address","invalid","self","audio","br","void","content","button","parent","colgroup","details","dd","dl","dt","figcaption","footer","header","img","rtc","tbody","td","tfoot","th","thead","tr","track","ul","video","createConfigBuilder","tagConfigs","TAGS","Object","BANNED_TAG_LIST","ALLOWED_TAG_LIST","FILTER_DENY","FILTER_CAST_NUMBER","FILTER_CAST_BOOL","ATTRIBUTES","alt","cite","FILTER_ALLOW","class","controls","datetime","default","disabled","dir","id","kind","label","lang","loading","loop","media","muted","poster","role","rowspan","scope","sizes","span","start","style","src","srclang","srcset","target","title","width","ATTRIBUTES_TO_PROPS","colspan","INVALID_STYLES","INVALID_ROOTS","OPEN_TOKEN","createDocument","banned","blocked","container","matchers","filters","keyIndex","constructor","markup","createContainer","props","applyAttributeFilters","name","applyNodeFilters","matchedString","elementIndex","parts","forEach","matcher","parentConfig","length","valid","tokenizedString","tokenName","elements","key","replaceTokens","canRenderChild","includes","noHtml","disableLineBreaks","nextMarkup","factory","el","innerHTML","convertLineBreaks","escapeHtml","Array","value","attr","newName","allowAttributes","count","extractStyleAttribute","styles","replace","getTagConfig","common","isTagAllowed","parse","transform","mergedText","elementProps","parseNode","open","startIndex","isVoid","match","text","endIndex","nodes","containerTagName","emptyContent","tag","mainContent","parsedContent","disableFilters","onAfterParse","onBeforeParse","noWrap","parserProps","allMatchers","allFilters","beforeCallbacks","afterCallbacks","nextString","parser","string","callback","pattern","index","greedy","options","propName","inverseName","createElement","element"],"mappings":"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","sourcesContent":["function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n// Generated with Packemon: https://packemon.dev\n// Platform: browser, Support: stable, Format: esm\nimport React from 'react';\nimport escapeHtml from 'escape-html';\n\nfunction Element(_ref) {\n  var _ref$attributes = _ref.attributes,\n      attributes = _ref$attributes === void 0 ? {} : _ref$attributes,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? null : _ref$children,\n      _ref$selfClose = _ref.selfClose,\n      selfClose = _ref$selfClose === void 0 ? false : _ref$selfClose,\n      Tag = _ref.tagName;\n  // @ts-expect-error BUG: https://github.com/Microsoft/TypeScript/issues/28806\n  return selfClose ? /*#__PURE__*/React.createElement(Tag, attributes) : /*#__PURE__*/React.createElement(Tag, attributes, children);\n}\n\nvar Filter = /*#__PURE__*/function () {\n  function Filter() {}\n\n  var _proto = Filter.prototype;\n\n  /**\n   * Filter and clean an HTML attribute value.\n   */\n  _proto.attribute = function attribute(name, value) {\n    return value;\n  }\n  /**\n   * Filter and clean an HTML node.\n   */\n  ;\n\n  _proto.node = function node(name, _node) {\n    return _node;\n  };\n\n  return Filter;\n}();\n/* eslint-disable no-bitwise, no-magic-numbers, sort-keys */\n// https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories\n\n\nvar TYPE_FLOW = 1;\nvar TYPE_SECTION = 1 << 1;\nvar TYPE_HEADING = 1 << 2;\nvar TYPE_PHRASING = 1 << 3;\nvar TYPE_EMBEDDED = 1 << 4;\nvar TYPE_INTERACTIVE = 1 << 5;\nvar TYPE_PALPABLE = 1 << 6; // https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n\nvar tagConfigs = {\n  a: {\n    content: TYPE_FLOW | TYPE_PHRASING,\n    self: false,\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_INTERACTIVE | TYPE_PALPABLE\n  },\n  address: {\n    invalid: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'address', 'article', 'aside', 'section', 'div', 'header', 'footer'],\n    self: false\n  },\n  audio: {\n    children: ['track', 'source']\n  },\n  br: {\n    type: TYPE_FLOW | TYPE_PHRASING,\n    void: true\n  },\n  body: {\n    content: TYPE_FLOW | TYPE_SECTION | TYPE_HEADING | TYPE_PHRASING | TYPE_EMBEDDED | TYPE_INTERACTIVE | TYPE_PALPABLE\n  },\n  button: {\n    content: TYPE_PHRASING,\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_INTERACTIVE | TYPE_PALPABLE\n  },\n  caption: {\n    content: TYPE_FLOW,\n    parent: ['table']\n  },\n  col: {\n    parent: ['colgroup'],\n    void: true\n  },\n  colgroup: {\n    children: ['col'],\n    parent: ['table']\n  },\n  details: {\n    children: ['summary'],\n    type: TYPE_FLOW | TYPE_INTERACTIVE | TYPE_PALPABLE\n  },\n  dd: {\n    content: TYPE_FLOW,\n    parent: ['dl']\n  },\n  dl: {\n    children: ['dt', 'dd'],\n    type: TYPE_FLOW\n  },\n  dt: {\n    content: TYPE_FLOW,\n    invalid: ['footer', 'header'],\n    parent: ['dl']\n  },\n  figcaption: {\n    content: TYPE_FLOW,\n    parent: ['figure']\n  },\n  footer: {\n    invalid: ['footer', 'header']\n  },\n  header: {\n    invalid: ['footer', 'header']\n  },\n  hr: {\n    type: TYPE_FLOW,\n    void: true\n  },\n  img: {\n    void: true\n  },\n  li: {\n    content: TYPE_FLOW,\n    parent: ['ul', 'ol', 'menu']\n  },\n  main: {\n    self: false\n  },\n  ol: {\n    children: ['li'],\n    type: TYPE_FLOW\n  },\n  picture: {\n    children: ['source', 'img'],\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_EMBEDDED\n  },\n  rb: {\n    parent: ['ruby', 'rtc']\n  },\n  rp: {\n    parent: ['ruby', 'rtc']\n  },\n  rt: {\n    content: TYPE_PHRASING,\n    parent: ['ruby', 'rtc']\n  },\n  rtc: {\n    content: TYPE_PHRASING,\n    parent: ['ruby']\n  },\n  ruby: {\n    children: ['rb', 'rp', 'rt', 'rtc']\n  },\n  source: {\n    parent: ['audio', 'video', 'picture'],\n    void: true\n  },\n  summary: {\n    content: TYPE_PHRASING,\n    parent: ['details']\n  },\n  table: {\n    children: ['caption', 'colgroup', 'thead', 'tbody', 'tfoot', 'tr'],\n    type: TYPE_FLOW\n  },\n  tbody: {\n    parent: ['table'],\n    children: ['tr']\n  },\n  td: {\n    content: TYPE_FLOW,\n    parent: ['tr']\n  },\n  tfoot: {\n    parent: ['table'],\n    children: ['tr']\n  },\n  th: {\n    content: TYPE_FLOW,\n    parent: ['tr']\n  },\n  thead: {\n    parent: ['table'],\n    children: ['tr']\n  },\n  tr: {\n    parent: ['table', 'tbody', 'thead', 'tfoot'],\n    children: ['th', 'td']\n  },\n  track: {\n    parent: ['audio', 'video'],\n    void: true\n  },\n  ul: {\n    children: ['li'],\n    type: TYPE_FLOW\n  },\n  video: {\n    children: ['track', 'source']\n  },\n  wbr: {\n    type: TYPE_FLOW | TYPE_PHRASING,\n    void: true\n  }\n};\n\nfunction createConfigBuilder(config) {\n  return function (tagName) {\n    tagConfigs[tagName] = _extends({}, config, tagConfigs[tagName]);\n  };\n}\n\n['address', 'main', 'div', 'figure', 'p', 'pre'].forEach(createConfigBuilder({\n  content: TYPE_FLOW,\n  type: TYPE_FLOW | TYPE_PALPABLE\n}));\n['abbr', 'b', 'bdi', 'bdo', 'cite', 'code', 'data', 'dfn', 'em', 'i', 'kbd', 'mark', 'q', 'ruby', 'samp', 'strong', 'sub', 'sup', 'time', 'u', 'var'].forEach(createConfigBuilder({\n  content: TYPE_PHRASING,\n  type: TYPE_FLOW | TYPE_PHRASING | TYPE_PALPABLE\n}));\n['p', 'pre'].forEach(createConfigBuilder({\n  content: TYPE_PHRASING,\n  type: TYPE_FLOW | TYPE_PALPABLE\n}));\n['s', 'small', 'span', 'del', 'ins'].forEach(createConfigBuilder({\n  content: TYPE_PHRASING,\n  type: TYPE_FLOW | TYPE_PHRASING\n}));\n['article', 'aside', 'footer', 'header', 'nav', 'section', 'blockquote'].forEach(createConfigBuilder({\n  content: TYPE_FLOW,\n  type: TYPE_FLOW | TYPE_SECTION | TYPE_PALPABLE\n}));\n['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].forEach(createConfigBuilder({\n  content: TYPE_PHRASING,\n  type: TYPE_FLOW | TYPE_HEADING | TYPE_PALPABLE\n}));\n['audio', 'canvas', 'iframe', 'img', 'video'].forEach(createConfigBuilder({\n  type: TYPE_FLOW | TYPE_PHRASING | TYPE_EMBEDDED | TYPE_PALPABLE\n})); // Disable this map from being modified\n\nvar TAGS = Object.freeze(tagConfigs); // Tags that should never be allowed, even if the allow list is disabled\n\nvar BANNED_TAG_LIST = ['applet', 'base', 'body', 'command', 'embed', 'frame', 'frameset', 'head', 'html', 'link', 'meta', 'noscript', 'object', 'script', 'style', 'title'];\nvar ALLOWED_TAG_LIST = Object.keys(TAGS).filter(function (tag) {\n  return tag !== 'canvas' && tag !== 'iframe';\n}); // Filters apply to HTML attributes\n\nvar FILTER_ALLOW = 1;\nvar FILTER_DENY = 2;\nvar FILTER_CAST_NUMBER = 3;\nvar FILTER_CAST_BOOL = 4;\nvar FILTER_NO_CAST = 5; // Attributes not listed here will be denied\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\n\nvar ATTRIBUTES = Object.freeze({\n  alt: FILTER_ALLOW,\n  cite: FILTER_ALLOW,\n  class: FILTER_ALLOW,\n  colspan: FILTER_CAST_NUMBER,\n  controls: FILTER_CAST_BOOL,\n  datetime: FILTER_ALLOW,\n  default: FILTER_CAST_BOOL,\n  disabled: FILTER_CAST_BOOL,\n  dir: FILTER_ALLOW,\n  height: FILTER_ALLOW,\n  href: FILTER_ALLOW,\n  id: FILTER_ALLOW,\n  kind: FILTER_ALLOW,\n  label: FILTER_ALLOW,\n  lang: FILTER_ALLOW,\n  loading: FILTER_ALLOW,\n  loop: FILTER_CAST_BOOL,\n  media: FILTER_ALLOW,\n  muted: FILTER_CAST_BOOL,\n  poster: FILTER_ALLOW,\n  role: FILTER_ALLOW,\n  rowspan: FILTER_CAST_NUMBER,\n  scope: FILTER_ALLOW,\n  sizes: FILTER_ALLOW,\n  span: FILTER_CAST_NUMBER,\n  start: FILTER_CAST_NUMBER,\n  style: FILTER_NO_CAST,\n  src: FILTER_ALLOW,\n  srclang: FILTER_ALLOW,\n  srcset: FILTER_ALLOW,\n  target: FILTER_ALLOW,\n  title: FILTER_ALLOW,\n  type: FILTER_ALLOW,\n  width: FILTER_ALLOW\n}); // Attributes to camel case for React props\n\nvar ATTRIBUTES_TO_PROPS = Object.freeze({\n  class: 'className',\n  colspan: 'colSpan',\n  datetime: 'dateTime',\n  rowspan: 'rowSpan',\n  srclang: 'srcLang',\n  srcset: 'srcSet'\n});\nvar INVALID_STYLES = /(url|image|image-set)\\(/i;\n\nvar StyleFilter = /*#__PURE__*/function (_Filter) {\n  _inheritsLoose(StyleFilter, _Filter);\n\n  function StyleFilter() {\n    return _Filter.apply(this, arguments) || this;\n  }\n\n  var _proto2 = StyleFilter.prototype;\n\n  _proto2.attribute = function attribute(name, value) {\n    if (name === 'style') {\n      Object.keys(value).forEach(function (key) {\n        if (String(value[key]).match(INVALID_STYLES)) {\n          // eslint-disable-next-line no-param-reassign\n          delete value[key];\n        }\n      });\n    }\n\n    return value;\n  };\n\n  return StyleFilter;\n}(Filter);\n/* eslint-disable no-bitwise, no-cond-assign, complexity */\n\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar INVALID_ROOTS = /^<(!doctype|(html|head|body)(\\s|>))/i;\nvar ALLOWED_ATTRS = /^(aria\\x2D|data\\x2D|[0-9A-Z_a-z\\u017F\\u212A]+:)/i;\nvar OPEN_TOKEN = /{{{(\\w+)\\/?}}}/;\n\nfunction createDocument() {\n  // Maybe SSR? Just do nothing instead of crashing!\n  if (typeof window === 'undefined' || typeof document === 'undefined') {\n    return undefined;\n  }\n\n  return document.implementation.createHTMLDocument('Interweave');\n}\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(markup, props, matchers, filters) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (matchers === void 0) {\n      matchers = [];\n    }\n\n    if (filters === void 0) {\n      filters = [];\n    }\n\n    this.allowed = void 0;\n    this.banned = void 0;\n    this.blocked = void 0;\n    this.container = void 0;\n    this.content = [];\n    this.props = void 0;\n    this.matchers = void 0;\n    this.filters = void 0;\n    this.keyIndex = void 0;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (markup && typeof markup !== 'string') {\n        throw new TypeError('Interweave parser requires a valid string.');\n      }\n    }\n\n    this.props = props;\n    this.matchers = matchers;\n    this.filters = [].concat(filters, [new StyleFilter()]);\n    this.keyIndex = -1;\n    this.container = this.createContainer(markup || '');\n    this.allowed = new Set(props.allowList || ALLOWED_TAG_LIST);\n    this.banned = new Set(BANNED_TAG_LIST);\n    this.blocked = new Set(props.blockList);\n  }\n  /**\n   * Loop through and apply all registered attribute filters.\n   */\n\n\n  var _proto3 = Parser.prototype;\n\n  _proto3.applyAttributeFilters = function applyAttributeFilters(name, value) {\n    return this.filters.reduce(function (nextValue, filter) {\n      return nextValue !== null && typeof filter.attribute === 'function' ? filter.attribute(name, nextValue) : nextValue;\n    }, value);\n  }\n  /**\n   * Loop through and apply all registered node filters.\n   */\n  ;\n\n  _proto3.applyNodeFilters = function applyNodeFilters(name, node) {\n    // Allow null to be returned\n    return this.filters.reduce(function (nextNode, filter) {\n      return nextNode !== null && typeof filter.node === 'function' ? filter.node(name, nextNode) : nextNode;\n    }, node);\n  }\n  /**\n   * Loop through and apply all registered matchers to the string.\n   * If a match is found, create a React element, and build a new array.\n   * This array allows React to interpolate and render accordingly.\n   */\n  ;\n\n  _proto3.applyMatchers = function applyMatchers(string, parentConfig) {\n    var _this = this;\n\n    var elements = {};\n    var props = this.props;\n    var matchedString = string;\n    var elementIndex = 0;\n    var parts = null;\n    this.matchers.forEach(function (matcher) {\n      var tagName = matcher.asTag().toLowerCase();\n\n      var config = _this.getTagConfig(tagName); // Skip matchers that have been disabled from props or are not supported\n\n\n      if (props[matcher.inverseName] || !_this.isTagAllowed(tagName)) {\n        return;\n      } // Skip matchers in which the child cannot be rendered\n\n\n      if (!_this.canRenderChild(parentConfig, config)) {\n        return;\n      } // Continuously trigger the matcher until no matches are found\n\n\n      var tokenizedString = '';\n\n      while (matchedString && (parts = matcher.match(matchedString))) {\n        var _parts = parts,\n            index = _parts.index,\n            length = _parts.length,\n            _match = _parts.match,\n            valid = _parts.valid,\n            isVoid = _parts.void,\n            partProps = _objectWithoutPropertiesLoose(_parts, [\"index\", \"length\", \"match\", \"valid\", \"void\"]);\n\n        var tokenName = matcher.propName + elementIndex; // Piece together a new string with interpolated tokens\n\n        if (index > 0) {\n          tokenizedString += matchedString.slice(0, index);\n        }\n\n        if (valid) {\n          tokenizedString += isVoid ? \"{{{\" + tokenName + \"/}}}\" : \"{{{\" + tokenName + \"}}}\" + _match + \"{{{/\" + tokenName + \"}}}\";\n          _this.keyIndex += 1;\n          elementIndex += 1;\n          elements[tokenName] = {\n            children: _match,\n            matcher: matcher,\n            props: _extends({}, props, partProps, {\n              key: _this.keyIndex\n            })\n          };\n        } else {\n          tokenizedString += _match;\n        } // Reduce the string being matched against,\n        // otherwise we end up in an infinite loop!\n\n\n        if (matcher.greedy) {\n          matchedString = tokenizedString + matchedString.slice(index + length);\n          tokenizedString = '';\n        } else {\n          // eslint-disable-next-line unicorn/explicit-length-check\n          matchedString = matchedString.slice(index + (length || _match.length));\n        }\n      } // Update the matched string with the tokenized string,\n      // so that the next matcher can apply to it.\n\n\n      if (!matcher.greedy) {\n        matchedString = tokenizedString + matchedString;\n      }\n    });\n\n    if (elementIndex === 0) {\n      return string;\n    }\n\n    return this.replaceTokens(matchedString, elements);\n  }\n  /**\n   * Determine whether the child can be rendered within the parent.\n   */\n  ;\n\n  _proto3.canRenderChild = function canRenderChild(parentConfig, childConfig) {\n    if (!parentConfig.tagName || !childConfig.tagName) {\n      return false;\n    } // No children\n\n\n    if (parentConfig.void) {\n      return false;\n    } // Valid children\n\n\n    if (parentConfig.children.length > 0) {\n      return parentConfig.children.includes(childConfig.tagName);\n    }\n\n    if (parentConfig.invalid.length > 0 && parentConfig.invalid.includes(childConfig.tagName)) {\n      return false;\n    } // Valid parent\n\n\n    if (childConfig.parent.length > 0) {\n      return childConfig.parent.includes(parentConfig.tagName);\n    } // Self nesting\n\n\n    if (!parentConfig.self && parentConfig.tagName === childConfig.tagName) {\n      return false;\n    } // Content category type\n\n\n    return Boolean(parentConfig && parentConfig.content & childConfig.type);\n  }\n  /**\n   * Convert line breaks in a string to HTML `<br/>` tags.\n   * If the string contains HTML, we should not convert anything,\n   * as line breaks should be handled by `<br/>`s in the markup itself.\n   */\n  ;\n\n  _proto3.convertLineBreaks = function convertLineBreaks(markup) {\n    var _this$props = this.props,\n        noHtml = _this$props.noHtml,\n        disableLineBreaks = _this$props.disableLineBreaks;\n\n    if (noHtml || disableLineBreaks || markup.match(/<((?:\\/[ a-z]+)|(?:[ a-z]+\\/))>/gi)) {\n      return markup;\n    } // Replace carriage returns\n\n\n    var nextMarkup = markup.replace(/\\r\\n/g, '\\n'); // Replace long line feeds\n\n    nextMarkup = nextMarkup.replace(/\\n{3,}/g, '\\n\\n\\n'); // Replace line feeds with `<br/>`s\n\n    nextMarkup = nextMarkup.replace(/\\n/g, '<br/>');\n    return nextMarkup;\n  }\n  /**\n   * Create a detached HTML document that allows for easy HTML\n   * parsing while not triggering scripts or loading external\n   * resources.\n   */\n  ;\n\n  _proto3.createContainer = function createContainer(markup) {\n    var factory = global.INTERWEAVE_SSR_POLYFILL || createDocument;\n    var doc = factory();\n\n    if (!doc) {\n      return undefined;\n    }\n\n    var tag = this.props.containerTagName || 'body';\n    var el = tag === 'body' || tag === 'fragment' ? doc.body : doc.createElement(tag);\n\n    if (markup.match(INVALID_ROOTS)) {\n      if (process.env.NODE_ENV !== \"production\") {\n        throw new Error('HTML documents as Interweave content are not supported.');\n      }\n    } else {\n      el.innerHTML = this.convertLineBreaks(this.props.escapeHtml ? escapeHtml(markup) : markup);\n    }\n\n    return el;\n  }\n  /**\n   * Convert an elements attribute map to an object map.\n   * Returns null if no attributes are defined.\n   */\n  ;\n\n  _proto3.extractAttributes = function extractAttributes(node) {\n    var _this2 = this;\n\n    var allowAttributes = this.props.allowAttributes;\n    var attributes = {};\n    var count = 0;\n\n    if (node.nodeType !== ELEMENT_NODE || !node.attributes) {\n      return null;\n    }\n\n    Array.from(node.attributes).forEach(function (attr) {\n      var name = attr.name,\n          value = attr.value;\n      var newName = name.toLowerCase();\n      var filter = ATTRIBUTES[newName] || ATTRIBUTES[name]; // Verify the node is safe from attacks\n\n      if (!_this2.isSafe(node)) {\n        return;\n      } // Do not allow denied attributes, excluding ARIA attributes\n      // Do not allow events or XSS injections\n\n\n      if (!newName.match(ALLOWED_ATTRS)) {\n        if (!allowAttributes && (!filter || filter === FILTER_DENY) || newName.startsWith('on') || value.replace(/(\\s|\\0|&#x0([9AD]);)/, '').match(/(javascript|vbscript|livescript|xss):/i)) {\n          return;\n        }\n      } // Apply attribute filters\n\n\n      var newValue = newName === 'style' ? _this2.extractStyleAttribute(node) : value; // Cast to boolean\n\n      if (filter === FILTER_CAST_BOOL) {\n        newValue = true; // Cast to number\n      } else if (filter === FILTER_CAST_NUMBER) {\n        newValue = Number.parseFloat(String(newValue)); // Cast to string\n      } else if (filter !== FILTER_NO_CAST) {\n        newValue = String(newValue);\n      }\n\n      attributes[ATTRIBUTES_TO_PROPS[newName] || newName] = _this2.applyAttributeFilters(newName, newValue);\n      count += 1;\n    });\n\n    if (count === 0) {\n      return null;\n    }\n\n    return attributes;\n  }\n  /**\n   * Extract the style attribute as an object and remove values that allow for attack vectors.\n   */\n  ;\n\n  _proto3.extractStyleAttribute = function extractStyleAttribute(node) {\n    var styles = {};\n    Array.from(node.style).forEach(function (key) {\n      var value = node.style[key];\n\n      if (typeof value === 'string' || typeof value === 'number') {\n        styles[key.replace(/-([a-z])/g, function (match, letter) {\n          return letter.toUpperCase();\n        })] = value;\n      }\n    });\n    return styles;\n  }\n  /**\n   * Return configuration for a specific tag.\n   */\n  ;\n\n  _proto3.getTagConfig = function getTagConfig(tagName) {\n    var common = {\n      children: [],\n      content: 0,\n      invalid: [],\n      parent: [],\n      self: true,\n      tagName: '',\n      type: 0,\n      void: false\n    }; // Only spread when a tag config exists,\n    // otherwise we use the empty `tagName`\n    // for parent config inheritance.\n\n    if (TAGS[tagName]) {\n      return _extends({}, common, TAGS[tagName], {\n        tagName: tagName\n      });\n    }\n\n    return common;\n  }\n  /**\n   * Verify that a node is safe from XSS and injection attacks.\n   */\n  ;\n\n  _proto3.isSafe = function isSafe(node) {\n    // URLs should only support HTTP, email and phone numbers\n    if (typeof HTMLAnchorElement !== 'undefined' && node instanceof HTMLAnchorElement) {\n      var href = node.getAttribute('href'); // Fragment protocols start with about:\n      // So let's just allow them\n\n      if (href && href.charAt(0) === '#') {\n        return true;\n      }\n\n      var protocol = node.protocol.toLowerCase();\n      return protocol === ':' || protocol === 'http:' || protocol === 'https:' || protocol === 'mailto:' || protocol === 'tel:';\n    }\n\n    return true;\n  }\n  /**\n   * Verify that an HTML tag is allowed to render.\n   */\n  ;\n\n  _proto3.isTagAllowed = function isTagAllowed(tagName) {\n    if (this.banned.has(tagName) || this.blocked.has(tagName)) {\n      return false;\n    }\n\n    return this.props.allowElements || this.allowed.has(tagName);\n  }\n  /**\n   * Parse the markup by injecting it into a detached document,\n   * while looping over all child nodes and generating an\n   * array to interpolate into JSX.\n   */\n  ;\n\n  _proto3.parse = function parse() {\n    if (!this.container) {\n      return [];\n    }\n\n    return this.parseNode(this.container, this.getTagConfig(this.container.nodeName.toLowerCase()));\n  }\n  /**\n   * Loop over the nodes children and generate a\n   * list of text nodes and React elements.\n   */\n  ;\n\n  _proto3.parseNode = function parseNode(parentNode, parentConfig) {\n    var _this3 = this;\n\n    var _this$props2 = this.props,\n        noHtml = _this$props2.noHtml,\n        noHtmlExceptMatchers = _this$props2.noHtmlExceptMatchers,\n        allowElements = _this$props2.allowElements,\n        transform = _this$props2.transform;\n    var content = [];\n    var mergedText = '';\n    Array.from(parentNode.childNodes).forEach(function (node) {\n      // Create React elements from HTML elements\n      if (node.nodeType === ELEMENT_NODE) {\n        var tagName = node.nodeName.toLowerCase();\n\n        var config = _this3.getTagConfig(tagName); // Persist any previous text\n\n\n        if (mergedText) {\n          content.push(mergedText);\n          mergedText = '';\n        } // Apply node filters first\n\n\n        var nextNode = _this3.applyNodeFilters(tagName, node);\n\n        if (!nextNode) {\n          return;\n        } // Apply transformation second\n\n\n        var children;\n\n        if (transform) {\n          _this3.keyIndex += 1;\n          var key = _this3.keyIndex; // Must occur after key is set\n\n          children = _this3.parseNode(nextNode, config);\n          var transformed = transform(nextNode, children, config);\n\n          if (transformed === null) {\n            return;\n          } else if (typeof transformed !== 'undefined') {\n            content.push( /*#__PURE__*/React.cloneElement(transformed, {\n              key: key\n            }));\n            return;\n          } // Reset as we're not using the transformation\n\n\n          _this3.keyIndex = key - 1;\n        } // Never allow these tags (except via a transformer)\n\n\n        if (_this3.banned.has(tagName)) {\n          return;\n        } // Only render when the following criteria is met:\n        //  - HTML has not been disabled\n        //  - Tag is allowed\n        //  - Child is valid within the parent\n\n\n        if (!(noHtml || noHtmlExceptMatchers && tagName !== 'br') && _this3.isTagAllowed(tagName) && (allowElements || _this3.canRenderChild(parentConfig, config))) {\n          _this3.keyIndex += 1; // Build the props as it makes it easier to test\n\n          var attributes = _this3.extractAttributes(nextNode);\n\n          var elementProps = {\n            tagName: tagName\n          };\n\n          if (attributes) {\n            elementProps.attributes = attributes;\n          }\n\n          if (config.void) {\n            elementProps.selfClose = config.void;\n          }\n\n          content.push( /*#__PURE__*/React.createElement(Element, _extends({}, elementProps, {\n            key: _this3.keyIndex\n          }), children || _this3.parseNode(nextNode, config))); // Render the children of the current element only.\n          // Important: If the current element is not allowed,\n          // use the parent element for the next scope.\n        } else {\n          content = content.concat(_this3.parseNode(nextNode, config.tagName ? config : parentConfig));\n        } // Apply matchers if a text node\n\n      } else if (node.nodeType === TEXT_NODE) {\n        var text = noHtml && !noHtmlExceptMatchers ? node.textContent : _this3.applyMatchers(node.textContent || '', parentConfig);\n\n        if (Array.isArray(text)) {\n          content = content.concat(text);\n        } else {\n          mergedText += text;\n        }\n      }\n    });\n\n    if (mergedText) {\n      content.push(mergedText);\n    }\n\n    return content;\n  }\n  /**\n   * Deconstruct the string into an array, by replacing custom tokens with React elements,\n   * so that React can render it correctly.\n   */\n  ;\n\n  _proto3.replaceTokens = function replaceTokens(tokenizedString, elements) {\n    if (!tokenizedString.includes('{{{')) {\n      return tokenizedString;\n    }\n\n    var nodes = [];\n    var text = tokenizedString;\n    var open = null; // Find an open token tag\n\n    while (open = text.match(OPEN_TOKEN)) {\n      var _open = open,\n          _match2 = _open[0],\n          tokenName = _open[1];\n      var startIndex = open.index;\n\n      var isVoid = _match2.includes('/');\n\n      if (process.env.NODE_ENV !== \"production\") {\n        if (!elements[tokenName]) {\n          throw new Error(\"Token \\\"\" + tokenName + \"\\\" found but no matching element to replace with.\");\n        }\n      } // Extract the previous non-token text\n\n\n      if (startIndex > 0) {\n        nodes.push(text.slice(0, startIndex)); // Reduce text so that the closing tag will be found after the opening\n\n        text = text.slice(startIndex);\n      }\n\n      var _elements$tokenName = elements[tokenName],\n          children = _elements$tokenName.children,\n          matcher = _elements$tokenName.matcher,\n          elementProps = _elements$tokenName.props;\n      var endIndex = void 0; // Use tag as-is if void\n\n      if (isVoid) {\n        endIndex = _match2.length;\n        nodes.push(matcher.createElement(children, elementProps)); // Find the closing tag if not void\n      } else {\n        var close = text.match(new RegExp(\"{{{/\" + tokenName + \"}}}\"));\n\n        if (process.env.NODE_ENV !== \"production\") {\n          if (!close) {\n            throw new Error(\"Closing token missing for interpolated element \\\"\" + tokenName + \"\\\".\");\n          }\n        }\n\n        endIndex = close.index + close[0].length;\n        nodes.push(matcher.createElement(this.replaceTokens(text.slice(_match2.length, close.index), elements), elementProps));\n      } // Reduce text for the next interation\n\n\n      text = text.slice(endIndex);\n    } // Extra the remaining text\n\n\n    if (text.length > 0) {\n      nodes.push(text);\n    } // Reduce to a string if possible\n\n\n    if (nodes.length === 0) {\n      return '';\n    } else if (nodes.length === 1 && typeof nodes[0] === 'string') {\n      return nodes[0];\n    }\n\n    return nodes;\n  };\n\n  return Parser;\n}();\n/* eslint-disable react/jsx-fragments */\n\n\nfunction Markup(props) {\n  var attributes = props.attributes,\n      containerTagName = props.containerTagName,\n      content = props.content,\n      emptyContent = props.emptyContent,\n      parsedContent = props.parsedContent,\n      tagName = props.tagName;\n  var tag = containerTagName || tagName || 'div';\n  var noWrap = tag === 'fragment' ? true : props.noWrap;\n  var mainContent;\n\n  if (parsedContent) {\n    mainContent = parsedContent;\n  } else {\n    var markup = new Parser(content || '', props).parse();\n\n    if (markup.length > 0) {\n      mainContent = markup;\n    }\n  }\n\n  if (!mainContent) {\n    mainContent = emptyContent;\n  }\n\n  if (noWrap) {\n    // eslint-disable-next-line react/jsx-no-useless-fragment\n    return /*#__PURE__*/React.createElement(React.Fragment, null, mainContent);\n  }\n\n  return /*#__PURE__*/React.createElement(Element, {\n    attributes: attributes,\n    tagName: tag\n  }, mainContent);\n}\n\nfunction Interweave(props) {\n  var attributes = props.attributes,\n      _props$content = props.content,\n      content = _props$content === void 0 ? '' : _props$content,\n      _props$disableFilters = props.disableFilters,\n      disableFilters = _props$disableFilters === void 0 ? false : _props$disableFilters,\n      _props$disableMatcher = props.disableMatchers,\n      disableMatchers = _props$disableMatcher === void 0 ? false : _props$disableMatcher,\n      _props$emptyContent = props.emptyContent,\n      emptyContent = _props$emptyContent === void 0 ? null : _props$emptyContent,\n      _props$filters = props.filters,\n      filters = _props$filters === void 0 ? [] : _props$filters,\n      _props$matchers = props.matchers,\n      matchers = _props$matchers === void 0 ? [] : _props$matchers,\n      _props$onAfterParse = props.onAfterParse,\n      onAfterParse = _props$onAfterParse === void 0 ? null : _props$onAfterParse,\n      _props$onBeforeParse = props.onBeforeParse,\n      onBeforeParse = _props$onBeforeParse === void 0 ? null : _props$onBeforeParse,\n      _props$tagName = props.tagName,\n      tagName = _props$tagName === void 0 ? 'span' : _props$tagName,\n      _props$noWrap = props.noWrap,\n      noWrap = _props$noWrap === void 0 ? false : _props$noWrap,\n      parserProps = _objectWithoutPropertiesLoose(props, [\"attributes\", \"content\", \"disableFilters\", \"disableMatchers\", \"emptyContent\", \"filters\", \"matchers\", \"onAfterParse\", \"onBeforeParse\", \"tagName\", \"noWrap\"]);\n\n  var allMatchers = disableMatchers ? [] : matchers;\n  var allFilters = disableFilters ? [] : filters;\n  var beforeCallbacks = onBeforeParse ? [onBeforeParse] : [];\n  var afterCallbacks = onAfterParse ? [onAfterParse] : []; // Inherit callbacks from matchers\n\n  allMatchers.forEach(function (matcher) {\n    if (matcher.onBeforeParse) {\n      beforeCallbacks.push(matcher.onBeforeParse.bind(matcher));\n    }\n\n    if (matcher.onAfterParse) {\n      afterCallbacks.push(matcher.onAfterParse.bind(matcher));\n    }\n  }); // Trigger before callbacks\n\n  var markup = beforeCallbacks.reduce(function (string, callback) {\n    var nextString = callback(string, props);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof nextString !== 'string') {\n        throw new TypeError('Interweave `onBeforeParse` must return a valid HTML string.');\n      }\n    }\n\n    return nextString;\n  }, content || ''); // Parse the markup\n\n  var parser = new Parser(markup, parserProps, allMatchers, allFilters); // Trigger after callbacks\n\n  var nodes = afterCallbacks.reduce(function (parserNodes, callback) {\n    var nextNodes = callback(parserNodes, props);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!Array.isArray(nextNodes)) {\n        throw new TypeError('Interweave `onAfterParse` must return an array of strings and React elements.');\n      }\n    }\n\n    return nextNodes;\n  }, parser.parse());\n  return /*#__PURE__*/React.createElement(Markup, {\n    attributes: attributes,\n    containerTagName: props.containerTagName,\n    emptyContent: emptyContent,\n    tagName: tagName,\n    noWrap: noWrap,\n    parsedContent: nodes.length === 0 ? undefined : nodes\n  });\n}\n/**\n * Trigger the actual pattern match and package the matched\n * response through a callback.\n */\n\n\nfunction match(string, pattern, callback, isVoid) {\n  if (isVoid === void 0) {\n    isVoid = false;\n  }\n\n  var matches = string.match(pattern instanceof RegExp ? pattern : new RegExp(pattern, 'i'));\n\n  if (!matches) {\n    return null;\n  }\n\n  return _extends({\n    match: matches[0],\n    void: isVoid\n  }, callback(matches), {\n    index: matches.index,\n    length: matches[0].length,\n    valid: true\n  });\n}\n\nvar Matcher = /*#__PURE__*/function () {\n  function Matcher(name, options, factory) {\n    this.greedy = false;\n    this.options = void 0;\n    this.propName = void 0;\n    this.inverseName = void 0;\n    this.factory = void 0;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!name || name.toLowerCase() === 'html') {\n        throw new Error(\"The matcher name \\\"\" + name + \"\\\" is not allowed.\");\n      }\n    } // @ts-expect-error\n\n\n    this.options = _extends({}, options);\n    this.propName = name;\n    this.inverseName = \"no\" + (name.charAt(0).toUpperCase() + name.slice(1));\n    this.factory = factory || null;\n  }\n  /**\n   * Attempts to create a React element using a custom user provided factory,\n   * or the default matcher factory.\n   */\n\n\n  var _proto4 = Matcher.prototype;\n\n  _proto4.createElement = function createElement(children, props) {\n    var element = this.factory ? /*#__PURE__*/React.createElement(this.factory, props, children) : this.replaceWith(children, props);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof element !== 'string' && ! /*#__PURE__*/React.isValidElement(element)) {\n        throw new Error(\"Invalid React element created from \" + this.constructor.name + \".\");\n      }\n    }\n\n    return element;\n  }\n  /**\n   * Trigger the actual pattern match and package the matched\n   * response through a callback.\n   */\n  ;\n\n  _proto4.doMatch = function doMatch(string, pattern, callback, isVoid) {\n    if (isVoid === void 0) {\n      isVoid = false;\n    }\n\n    return match(string, pattern, callback, isVoid);\n  }\n  /**\n   * Callback triggered before parsing.\n   */\n  ;\n\n  _proto4.onBeforeParse = function onBeforeParse(content, props) {\n    return content;\n  }\n  /**\n   * Callback triggered after parsing.\n   */\n  ;\n\n  _proto4.onAfterParse = function onAfterParse(content, props) {\n    return content;\n  }\n  /**\n   * Replace the match with a React element based on the matched token and optional props.\n   */\n  ;\n\n  return Matcher;\n}();\n/**\n * @copyright   2016-2019, Miles Johnson\n * @license     https://opensource.org/licenses/MIT\n */\n\n\nexport default Interweave;\nexport { ALLOWED_TAG_LIST, ATTRIBUTES, ATTRIBUTES_TO_PROPS, BANNED_TAG_LIST, Element, FILTER_ALLOW, FILTER_CAST_BOOL, FILTER_CAST_NUMBER, FILTER_DENY, FILTER_NO_CAST, Filter, Markup, Matcher, Parser, TAGS, TYPE_EMBEDDED, TYPE_FLOW, TYPE_HEADING, TYPE_INTERACTIVE, TYPE_PALPABLE, TYPE_PHRASING, TYPE_SECTION, match };\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"module"}